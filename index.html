<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="utf-8">
	<title>RFC時計 Stand alone</title>
	<script type="text/javascript">
		/**
		 * Get the URL parameter value
		 *
		 * @param  name {string} パラメータのキー文字列
		 * @return  url {url} 対象のURL文字列（任意）
		 */
		function getParam(name, url) {
			if (!url) url = window.location.href;
			name = name.replace(/[\[\]]/g, "\\$&");
			var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
				results = regex.exec(url);
			if (!results) return null;
			if (!results[2]) return '';
			return decodeURIComponent(results[2].replace(/\+/g, " "));
		}

		var delay = 0;
		if (getParam("deley") !== null) {
			var delay = getParam("deley");
		}
		//特殊モード（秩父夜祭花火用）
		var event = null;
		if (getParam("event") !== null) {
			event = getParam("event");
		}

		//打ち上げ開始時刻
		var hanabi_start = 18;
		var minute1;//グローバル変数に昇格
		function clock() {
			var param = location.search;
			var infotext = "本日もダイヤ運転にお越しいただきありがとうございます。";
			if (getParam("infotext") !== null) {
				infotext = getParam("infotext");
			}

			document.getElementById('infotext').innerHTML = decodeURI(infotext);

			var delay_button;
			var now = new Date();
			var year = now.getFullYear();
			var month = now.getMonth() + 1;
			var date = now.getDate();
			var hour = now.getHours();
			minute1 = now.getMinutes();
			var minute2 = now.getMinutes();
			var second = now.getSeconds();
			minute1 = minute1 - delay;
			if (month < 10) {
				month = "0" + month;
			}
			if (date < 10) {
				date = "0" + date;
			}
			if (hour < 10) {
				hour = "0" + hour;
			}
			if (minute1 > 29) {
				minute1 = minute1 - 30;
			}
			if (minute1 < 0) {
				minute1 = minute1 + 30;
			}
			if (minute1 < 10) {
				minute1 = "0" + minute1;
			}
			if (minute2 < 10) {
				minute2 = "0" + minute2;
			}
			if (second < 10) {
				second = "0" + second;
			}
			document.getElementById('RFCClock').innerHTML = minute1 + ":" + second;
			document.getElementById('Calendar').innerHTML = "現在時刻" + "  " + year + "/" + month + "/" + date + " " + hour +
				":" + minute2 + ":" + second;
			window.setTimeout("clock()", 1000);
		}
		window.onload = clock;
		window.addEventListener('load', function () {
			delay_button = document.getElementById("RFCClock");
			// delay_button.onclick = function () {
			// 	if (delay <= 30) {
			// 		delay = delay + 5;
			// 	} else {
			// 		delay = delay - 25;
			// 	}
			// }
		})
	</script>
	<style type="text/css">
		body {
			margin-top: 7vh;
			color: #FFF;
			background: #000;
			text-align: center;
			font-family:
				"Helvetica",
				"Arial",
				"A-OTF Shin Go Pro",
				"Meiryo",
				"MS PGothic",
				"Hiragino Kaku Gothic Pro",
				sans-serif;
		}

		.Model {
			font-weight: Bold;
			font-size: 300%;
			line-height: 50%;
		}

		.RFCClock {
			font-weight: Bold;
			font-size: 2000%;
			line-height: 100%;
		}

		.Calendar {
			font-weight: Normal;
			font-size: 300%;
			line-height: 100%;
		}

		.Scroll {
			font-family: "Meiryo";
			margin: auto;
			margin-top: 0.5%;
			width: 100%;
			font-weight: Bold;
			font-size: 200%;
			line-height: 120%;
			text-align: center;
			border: none;
			color: #000;
			background: #FFF;
			overflow: hidden;
		}

		.Scroll span {
			display: inline-block;
			padding-left: 100%;
			white-space: pre;
			animation: scrollAnime 10s linear infinite;
			/* ←何秒で表示を一巡させるかの設定(scrollAnime "n"s) */
		}

		@keyframes scrollAnime {
			0% {
				transform: translateX(0)
			}

			100% {
				transform: translateX(-100%)
			}
		}
	</style>
</head>

<body>
	<div class="Model">模型時刻</div>
	<div id="RFCClock" class="RFCClock"></div>
	<div id="Calendar" class="Calendar"></div>
	<script src="./lib/p5.min.js"></script>
	<script>
		const Y_AXIS = 1;
		const X_AXIS = 2;
		let canvas;
		let fireworks = [];
		let star = [];

		function windowResized() {
			resizeCanvas(document.documentElement.clientWidth, document.documentElement.clientHeight);
			this.preStar();
		}

		function setup() {
			// キャンバスの設定
			canvas = createCanvas(document.documentElement.clientWidth, document.documentElement.clientHeight);
			canvas.position(0, 0);
			canvas.style("z-index", "-1");
			colorMode(RGB);
			frameRate(60);
			this.preStar();
		}

		function draw() {
			// 背景色を設定
			if (event == "hanabi") {
				//はなびぃ
				setGradient(0, 0, width, height, color(0, 0, 0), color(24, 32, 72), Y_AXIS);
				noStroke();

				// 星を描く
				if(hanabi_start <= minute1){
					this.drawStar();
				}
				// 花火を打ち上げる間隔を調整
				if (0 === frameCount % 100) {
					// 打ち上がるスピード
					let speed = random(10, 30);
					fireworks.push(new FireWork(random(width), height, 0, speed, 0.98));
				}

				for (let fw of fireworks) {
					// 打ち切った花火を処理対象から外す（配列から削除する）
					if (2 === fw.getType || 30000 < fw.getFrame || !(hanabi_start <= minute1)) {
						fireworks = fireworks.filter((n) => n !== fw);
						continue;
					}

					// 打ち上げアニメーションを呼び出す
					if(hanabi_start <= minute1){
						fw.fire();
					}

				}
			}

		}

		class FireWork {
			// 初期設定
			constructor(x, y, vx, vy, gv) {
				// フレームカウンター
				this.frame = 0;
				this.type = 0;
				this.next = 0;
				// 花火の色
				this.r = random(155) + 80;
				this.g = random(155) + 80;
				this.b = random(155) + 80;
				this.a = 255;

				// 初期位置
				this.x = x;
				this.y = y;

				// 玉の大きさ
				this.w = random(10, 5);

				// 打ち上がる高さ
				this.maxHeight = random(height / 6, height / 2);
				this.fireHeight = height - this.maxHeight;

				// 重力
				this.vx = vx;
				this.vy = vy;
				this.gv = gv;

				// 残像表示用配列
				this.afterImages = [];
				// 爆発用配列
				this.explosions = [];

				// 消えてから爆発までの遅延時間
				this.exDelay = random(10, 40);
				// 爆発の大きさ
				this.large = random(5, 15);
				// 爆発の玉の数
				this.ball = random(20, 100);
				// 爆発から消えるまでの長さ
				this.exend = random(20, 40);
				// 爆発のブレーキ
				this.exStop = 0.96;
			}

			get getFrame() {
				return this.frame;
			}

			get getType() {
				return this.type;
			}

			// 処理コントロール
			fire() {
				// 0:打ち上げ（初期） 1:爆発
				switch (this.type) {
					case 0:
						this.rising();
						break;
					case 1:
						this.explosion();
						break;
				}
			}

			// 打ち上げアニメーション
			rising() {
				// 頂点まで達したら消す
				if (this.y * 0.8 < this.maxHeight) {
					this.a = this.a - 6;
				}

				// 指定の高さまで上昇する
				this.x += this.vx;
				this.y -= this.vy * ((this.fireHeight - (height - this.y)) / this.fireHeight);

				// 残像を表示
				this.afterImages.push(new Afterimage(this.r, this.g, this.b, this.x, this.y, this.w, this.a));
				for (let ai of this.afterImages) {
					if (ai.getAlpha <= 0) {
						this.afterImages = this.afterImages.filter((n) => n !== ai);
						continue;
					}
					ai.rsImage();
				}

				// 打ち上げ表示
				this.update(this.x, this.y, this.w);

				// 全ての表示が消えたら処理の種類を変更する
				if (0 == this.afterImages.length) {
					if (0 === this.next) {
						// 消えてから爆発まで遅延させる
						this.next = this.frame + Math.round(this.exDelay);
					} else if (this.next === this.frame) {
						// 花火の大きさ
						for (let i = 0; i < this.ball; i++) {
							// 爆発の角度
							let r = random(0, 360);
							// 花火の内側を作る（バラバラ）
							let s = random(0.1, 0.9);
							let vx = Math.cos((r * Math.PI) / 180) * s * this.large;
							let vy = Math.sin((r * Math.PI) / 180) * s * this.large;
							this.explosions.push(new FireWork(this.x, this.y, vx, vy, this.exStop));
							// 花火の輪郭を作る（丸くなるようにする）
							let cr = random(0, 360);
							let cs = random(0.9, 1);
							let cvx = Math.cos((cr * Math.PI) / 180) * cs * this.large;
							let cvy = Math.sin((cr * Math.PI) / 180) * cs * this.large;
							this.explosions.push(new FireWork(this.x, this.y, cvx, cvy, this.exStop));
						}
						this.a = 255;
						this.type = 1;
					}
				}
			}

			// 爆発アニメーション
			explosion() {
				for (let ex of this.explosions) {
					ex.frame++;
					// 爆発し終わった花火を配列から除去する
					if (2 === ex.getType) {
						this.explosions = this.explosions.filter((n) => n !== ex);
						continue;
					}

					// 残像を描画
					if (0 === Math.round(random(0, 32))) {
						ex.afterImages.push(new Afterimage(this.r, this.g, this.b, ex.x, ex.y, ex.w, ex.a));
					}

					for (let ai of ex.afterImages) {
						if (ai.getAlpha < 0) {
							ex.afterImages = ex.afterImages.filter((n) => n !== ai);
							continue;
						}
						ai.exImage();
					}

					// 爆発を描画
					this.update(ex.x, ex.y, ex.w, ex.a);
					ex.x += ex.vx;
					ex.y += ex.vy;
					ex.vx = ex.vx * ex.gv;
					ex.vy = ex.vy * ex.gv;
					ex.vy = ex.vy + ex.gv / 30;
					if (this.exend < ex.frame) {
						ex.w -= 0.1;
						ex.a = ex.a - 4;
						if (ex.a < 0 && 0 === ex.afterImages.length) {
							ex.type = 2;
						}
					}
				}
			}

			// 花火を表示する
			update(x, y, w, a) {
				this.frame++;
				if (0 < this.a) {
					let c = color(this.r, this.g, this.b);
					c.setAlpha(a);
					fill(c);
					ellipse(x, y, w, w);
				}
			}
		}

		// 残像処理用クラス
		class Afterimage {
			constructor(r, g, b, x, y, w, a) {
				this.frame = 0;
				this.r = r;
				this.g = g;
				this.b = b;
				this.x = x;
				this.y = y;
				this.w = w;
				this.a = a;
				this.vx = random(-0.24, 0.24);
				this.vy = random(0.2, 0.8);
				this.vw = random(0.05, 0.2);
			}

			get getAlpha() {
				return this.a;
			}

			// 打ち上げ用
			rsImage() {
				if (0 < this.a) {
					this.update(this.r, this.g, this.b, this.x, this.y, this.w, this.a);
					this.r += 4;
					this.g += 4;
					this.b += 4;
					this.x = this.x + this.vx;
					this.y = this.y + this.vy;
					if (0 < this.w) {
						this.w = this.w - this.vw;
					}
					this.a = this.a - 4;
				}
			}

			// 爆発用
			exImage() {
				if (0 < this.a) {
					this.update(this.r, this.g, this.b, this.x, this.y, this.w, this.a);
					this.r += 2.5;
					this.g += 2.5;
					this.b += 2.5;
					this.x = this.x + this.vx;
					this.y = this.y + this.vy;
					if (0 < this.w) {
						this.w = this.w - this.vw;
					}
					this.a = this.a - 1.5;
				}
			}

			update(r, g, b, x, y, w, a) {
				this.frame++;
				let c = color(r, g, b);
				c.setAlpha(a);
				fill(c);
				ellipse(x, y, w, w);
			}
		}

		// グラデーションを描画
		function setGradient(x, y, w, h, c1, c2, axis) {
			noFill();

			if (axis === Y_AXIS) {
				// Top to bottom gradient
				for (let i = y; i <= y + h; i++) {
					let inter = map(i, y, y + h, 0, 1);
					let c = lerpColor(c1, c2, inter);
					stroke(c);
					line(x, i, x + w, i);
				}
			} else if (axis === X_AXIS) {
				// Left to right gradient
				for (let i = x; i <= x + w; i++) {
					let inter = map(i, x, x + w, 0, 1);
					let c = lerpColor(c1, c2, inter);
					stroke(c);
					line(i, y, i, y + h);
				}
			}
		}

		// 星を作成
		function preStar() {
			star = [];
			for (let i = 0; i < 100; i++) {
				star.push([random(width), random(height / 2), random(1, 4)]);
			}
		}

		// 星を描画
		function drawStar() {
			// 星を描く
			for (let s of star) {
				let c = color(random(150, 255), random(150, 255), 255);
				c.setAlpha(random(150, 200));
				fill(c);
				ellipse(s[0], s[1], s[2], s[2]);
			}
		}
	</script>
	<noscript>
		<div align="center" style="font-size: 300%; font-weight: bold;">JavaScriptを有効にしてください。</div>
	</noscript>
	<div class="Scroll">
		<span id="infotext">　　-RFC時計-　ここに情報を入力することができます。　　</span>
		<!--この行にスクロール情報を入力-->
	</div>
</body>

</html>
<!--© 2019-2020 D.Kubota-->